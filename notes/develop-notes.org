* hy compiler internal notes
** + in Result object

to convert a plain ast object into Result Object

#+BEGIN_SRC hy
  (+ (Result) ast)
#+END_SRC
** =expr= in =Result=

The =expr= property in =Result= class doesn't directly generate codes. It's main purpose is to store an expression that is the result of a Result instance.

A lisp sexp will compile to either a pure expression (function call, number etc.) or a bunch of statements in lua/python. In the case of pure expression, it's simple. In the case of some statements, we need a expression to store the result of these statement and assign it to =Result.expr=. So if other lisp sexp want the result of this lisp sexp, it can get it with =Result.expr=.

Which expression to be saved as =Result.expr=, and when to use other =Result= objects' =expr=, is completely determined by the compiling function. There are no magic to automatically decide these things.

Is an expression to store the result of Result object. Instead of some magic, this expression is manually selected and added by compiling function for different atoms, for example, for assignment, the following code is used:

#+BEGIN_SRC hy
  (+= result ld-name)
#+END_SRC

where =ld-name= is the expression assigned by assignment function (e.g. the a in =(setv a 4)=)

while in =compile-if= function, the following code is used:

#+BEGIN_SRC hy
  (+= ret (apply Result []
                 {"expr" expr-name "temp_vars" [expr-name
                                                var]}))
#+END_SRC

Where =expr-name= is the generated anonymous variable (unless renamed later).

After stored, the =expr= also need to be used manually. For example, in =compile-if=, to use the returned expr from body an orel, we have:

#+BEGIN_SRC hy
  (+= body (mlast.Set [var] [body.force-expr]))
  (+= orel (mlast.Set [var] [orel.force-expr]))
#+END_SRC
where =var= is generated anonymous variable same as =expr-name= above.

For a more complex example, let's first list =compile-if='s source:

#+BEGIN_SRC hy
  [compile-if
   (with-decorator (builds "if")
     (fn [self expression]
       (.pop expression 0)
       (let [[condition (.compile self (.pop expression 0))]
             [body (.compile self (.pop expression 0))]
             [orel (if (empty? expression)
                     (Result)
                     (.compile self (.pop expression 0)))]
             [ret condition]
             
             [var-name (.get-anon-var self)]
             [var (mlast.Id var-name)]

             [expr-name (mlast.Id (ast-str var-name))]]

         ;; we won't test if statements in body or orel because lua doesn't have official ternary operator support

         ;;          (+= ret (mlast.Local [var]))
         (setv ret (+ (Result) (mlast.Local [var]) ret))
         (+= body (mlast.Set [var] [body.force-expr]))
         (+= orel (mlast.Set [var] [orel.force-expr]))
         (+= ret (mlast.If ret.force-expr body.stmts orel.stmts))
         (+= ret (apply Result []
                        {"expr" expr-name "temp_vars" [expr-name
                                                       var]}))
         ret
         )))]

#+END_SRC

And we have an example below

#+BEGIN_SRC hy
  (def a (if (setv x 1)
           (if true (setv c 2)
               (setv d 4))
           3))

#+END_SRC

which resulting the following codes.

#+BEGIN_SRC lua
  local a

  x = 1

  if x then
    local _hua_anon_var_1
    if True then
      c = 2
      _hua_anon_var_1 = c
    else
      d = 4
      _hua_anon_var_1 = d
    end
    a = _hua_anon_var_1
  else
    a = 3
  end

#+END_SRC

The first =if='s condition is =(setv x 1)=. In =compile-if='s code we can see that we first compile the condition and assign it with =ret=. The =expr= of =ret= is =(Id x)=. After compiling =body= and =orel=, we construct the whole =if= form with the following line:

#+BEGIN_SRC hy
  (+= ret (mlast.If ret.force-expr body.stmts orel.stmts))
#+END_SRC

Remember the result of condition is stored in =ret.expr=. That's how the compiled lua code workds


* hua implementation notes
** =setv/def=

Unlike python, lua's scoping is not local by default. Hence we differentiate =setv= and =def= where =(setv a 1)= resulting =a = 1= while =(def a 1)= resulting =local a = 1=.

More difference will come in the following case:
* hua vs hy
- =def=/=setv= differs
- a =local= keyword?
- no =defclass=
- no =defmacro=
- no quote/unquote because no =defmacro=?
- better scoping rules, which means nested =let= should work.
